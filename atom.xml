<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-02-17T03:52:41.102Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2025/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2025/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2025-02-17T04:00:00.000Z</published>
    <updated>2025-02-17T03:52:41.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="1-策略模式基本内容"><a href="#1-策略模式基本内容" class="headerlink" title="1.策略模式基本内容"></a>1.策略模式基本内容</h2><p><strong>策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</strong></p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240616161906028.png" alt="image-20240616161906028"></p><h2 id="2-自定义starter中的策略模式"><a href="#2-自定义starter中的策略模式" class="headerlink" title="2.自定义starter中的策略模式"></a>2.自定义starter中的策略模式</h2><ol><li><p>限流策略模式实现滑动窗口和漏桶限流：</p><ol><li><p>用的是抽象类实现策略接口，具体策略继承抽象策略：</p><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240616163551414.png" alt="image-20240616163551414"></p></li><li><p>使用@ConditionalOnProperty实现加载要使用的Bean：</p></li><li><pre><code class="language-Go">@ConditionalOnProperty(prefix = &quot;frequency-control&quot;, name = &quot;strategy-type&quot;, havingValue = &quot;slide_window&quot;)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 通过抽象类实现两种种限流规则，可以由核心配置设置：</span><br><span class="line"></span><br><span class="line">5. ```Go</span><br><span class="line">   frequency-control:</span><br><span class="line">     strategy-type: leaky_bucket</span><br></pre></td></tr></table></figure></code></pre></li></ol></li></ol><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p><strong>参考原文链接</strong>：<a href="https://blog.csdn.net/weixin_43734095/article/details/122318746">https://blog.csdn.net/weixin_43734095/article/details/122318746</a></p><h2 id="1-基本内容"><a href="#1-基本内容" class="headerlink" title="1.基本内容"></a>1.基本内容</h2><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240617000610097.png" alt="image-20240617000610097"></p><h3 id="1-抽象工厂模式的主要角色如下："><a href="#1-抽象工厂模式的主要角色如下：" class="headerlink" title="1.抽象工厂模式的主要角色如下："></a>1.抽象工厂模式的主要角色如下：</h3><ul><li>抽象工厂：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li><li>具体工厂：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li></ul><h3 id="2-优缺点"><a href="#2-优缺点" class="headerlink" title="2.优缺点"></a>2.优缺点</h3><ul><li><p>优点：</p><ul><li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</li><li>想要生产一个产品族的产品，只需要一个接口或类。</li></ul></li><li><p>缺点：</p><ul><li>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</li></ul></li></ul><h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3.使用场景"></a>3.使用场景</h3><ul><li><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</p></li><li><p>系统中有多个产品族，但每次只使用其中的某一族产品，如有人只喜欢穿某一个品牌的衣服和鞋。</p></li><li><p>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</p></li><li><p>如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。</p></li></ul><h2 id="2-应用拓展"><a href="#2-应用拓展" class="headerlink" title="2.应用拓展"></a>2.应用拓展</h2><p>可以通过工厂模式 + 配置文件的方式解除工厂对象和产品对象的耦合，在工厂类中加载配置文件中的全类名。</p><p>第一步：定义配置文件 bean.properties（使用 .properties 是为了方便演示）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">american</span>=<span class="string">com.itheima.pattern.factory.config_factory.AmericanCoffee</span></span><br><span class="line"><span class="attr">latte</span>=<span class="string">com.itheima.pattern.factory.config_factory.LatteCoffee</span></span><br></pre></td></tr></table></figure><p>第二步：改进工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 加载配置文件，获取配置文件中配置的全类名，并创建该类的对象进行存储</span></span><br><span class="line">    <span class="comment">// 1,定义容器对象存储咖啡对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, Coffee&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2,加载配置文件，只需要加载一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 2.1 创建Properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 2.2 调用p对象中的load方法进行配置文件的加载</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> CoffeeFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;bean.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p.load(is);</span><br><span class="line">            <span class="comment">// 从p集合中获取全类名并创建对象</span></span><br><span class="line">            Set&lt;Object&gt; keys = p.keySet();</span><br><span class="line">            <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> p.getProperty((String) key);</span><br><span class="line">                <span class="comment">// 通过反射技术创建对象</span></span><br><span class="line">                <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> (Coffee) clazz.newInstance();</span><br><span class="line">                <span class="comment">// 将名称和对象存储到容器中</span></span><br><span class="line">                map.put((String) key, coffee);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据名称获取对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员变量用来存储创建的对象，键存储的是名称，值存储的是对应的对象；</p><p>读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p><strong>参考原文链接</strong>：<a href="https://blog.csdn.net/weixin_43734095/article/details/122308030">https://blog.csdn.net/weixin_43734095/article/details/122308030</a></p><h2 id="1-单例模式的实现"><a href="#1-单例模式的实现" class="headerlink" title="1.单例模式的实现"></a>1.单例模式的实现</h2><ul><li><h3 id="单例设计模式分类两种："><a href="#单例设计模式分类两种：" class="headerlink" title="单例设计模式分类两种："></a>单例设计模式分类两种：</h3></li><li><p><strong>饿汉式</strong>：类加载就会导致该单实例对象被创建</p></li><li><p><strong>懒汉式</strong>：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></li></ul><h3 id="a-饿汉式："><a href="#a-饿汉式：" class="headerlink" title="a.饿汉式："></a>a.饿汉式：</h3><h4 id="1-静态代码块"><a href="#1-静态代码块" class="headerlink" title="1.静态代码块"></a>1.静态代码块</h4><p>该方式在成员位置声明 Singleton 类型的静态变量，而对象的创建是在静态代码块中，也是随着类的加载而创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式: 静态代码块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 声明Singleton类型的变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance; <span class="comment">// null</span></span><br><span class="line">    <span class="comment">//在静态代码块中进行赋值</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//对外提供获取该类对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-枚举"><a href="#2-枚举" class="headerlink" title="2.枚举"></a>2.枚举</h4><p>枚举方式是<strong>饿汉式</strong>单例模式，如果不考虑浪费内存空间的问题，这是极力推荐的单例实现模式。因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式。枚举的写法非常简单，而且枚举方式是所用单例实现中<strong>唯一一种不会被破坏</strong>的单例实现模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式：枚举实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="应用中的发现："><a href="#应用中的发现：" class="headerlink" title="应用中的发现："></a>应用中的发现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举类型的饿汉式单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">ContainerHolder</span> &#123;</span><br><span class="line">    </span><br><span class="line">    HOLDER;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanContainer instance;</span><br><span class="line">    </span><br><span class="line">    ContainerHolder() &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">BeanContainer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Bean容器实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BeanContainer <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ContainerHolder.HOLDER.instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="b-懒汉式："><a href="#b-懒汉式：" class="headerlink" title="b.懒汉式："></a>b.懒汉式：</h3><h4 id="1-双重检查锁🚀"><a href="#1-双重检查锁🚀" class="headerlink" title="1.双重检查锁🚀"></a>1.<strong>双重检查锁🚀</strong></h4><p>再来讨论一下懒汉模式中加锁的问题，对于 getInstance() 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以没有必要让每个线程必须持有锁才能调用该方法，可以调整加锁的时机。</p><p>由此产生了一种新的实现方式：双重检查锁模式（double check）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查锁方式(标准)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 声明Singleton类型的变量,使用volatile保证可见性和有序性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 对外提供公共的访问方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次判断,如果instance不为null,不需要抢占锁,直接返回对象</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次判断,抢占到锁以后再次判断</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-静态内部类🚀"><a href="#2-静态内部类🚀" class="headerlink" title="2.静态内部类🚀"></a>2.静态内部类🚀</h4><p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中，是不会加载静态内部类的，只有内部类的属性&#x2F;方法被调用时才会被加载，并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 定义一个静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="comment">// 在内部类中声明并初始化外部类的对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 提供公共的访问方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次加载 Singleton 类时不会去初始化 INSTANCE，只有第一次调用 getInstance()，虚拟机加载 SingletonHolder 并初始化 INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p><p>静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="1-基本内容-1"><a href="#1-基本内容-1" class="headerlink" title="1.基本内容"></a>1.基本内容</h2><p><strong>参考原文链接</strong>：<a href="https://blog.csdn.net/weixin_43734095/article/details/122318746">https://blog.csdn.net/weixin_43734095/article/details/122318746</a></p><h3 id="1-工厂方法模式的主要角色："><a href="#1-工厂方法模式的主要角色：" class="headerlink" title="1.工厂方法模式的主要角色："></a>1.工厂方法模式的<strong>主要角色</strong>：</h3><ul><li><p>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</p></li><li><p>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</p></li><li><p>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</p></li><li><p>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</p></li></ul><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240616181051638.png" alt="image-20240616181051638"></p><h3 id="2-优缺点-1"><a href="#2-优缺点-1" class="headerlink" title="2.优缺点"></a>2.优缺点</h3><ul><li><p>优点：</p><ul><li><p>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</p></li><li><p>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则。</p></li></ul></li><li><p>缺点：</p><ul><li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，增加了系统的复杂度。</li></ul></li></ul><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><h2 id="1-基本内容-2"><a href="#1-基本内容-2" class="headerlink" title="1.基本内容"></a>1.基本内容</h2><ul><li><p>模板方法（Template Method）模式包含以下主要角色：</p><ul><li><p>抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p><ul><li><p>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p></li><li><p>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：</p></li><li><p>抽象方法 (Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。</p></li><li><p>具体方法 (Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</p></li><li><p>钩子方法 (Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p><ul><li>一般钩子方法是用于判断的逻辑方法，这类方法名一般为 isXxx，返回值类型为 boolean 类型。</li></ul></li></ul></li><li><p>具体子类（Concrete Class）：</p><ul><li>实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</li></ul></li></ul></li></ul><p><img src="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20240617171613875.png" alt="image-20240617171613875"></p><h3 id="2-优缺点-2"><a href="#2-优缺点-2" class="headerlink" title="2.优缺点"></a>2.优缺点</h3><p>优点：</p><ul><li><p>提高代码复用性：将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p></li><li><p>实现了反向控制：通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，符合“开闭原则”。</p></li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li><p>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</p></li><li><p>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h1&gt;&lt;h2 id=&quot;1-策略模式基本内容&quot;&gt;&lt;a href=&quot;#1-策略模式基本内容&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="java学习" scheme="http://example.com/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java容器</title>
    <link href="http://example.com/2025/02/17/java%E9%9D%A2%E8%AF%95%E9%A2%98/java%20%E5%AE%B9%E5%99%A8/"/>
    <id>http://example.com/2025/02/17/java%E9%9D%A2%E8%AF%95%E9%A2%98/java%20%E5%AE%B9%E5%99%A8/</id>
    <published>2025-02-17T04:00:00.000Z</published>
    <updated>2025-03-16T03:06:18.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-容器"><a href="#java-容器" class="headerlink" title="java 容器"></a>java 容器</h1><h3 id="18-Java-容器都有哪些？"><a href="#18-Java-容器都有哪些？" class="headerlink" title="18. Java 容器都有哪些？"></a><strong>18. Java 容器都有哪些？</strong></h3><p>Java 容器主要分为两大类：<strong>Collection</strong> 和 <strong>Map</strong>。</p><ul><li><p><strong>Collection</strong>（存储单元素）：</p><ul><li><p><strong>List</strong>（有序、可重复）：</p><ul><li><code>ArrayList</code>​（动态数组）</li><li><code>LinkedList</code>​（双向链表）</li><li><code>Vector</code>​（线程安全的动态数组，已过时）</li><li><code>Stack</code>​（栈，继承自 <code>Vector</code>​）</li></ul></li><li><p><strong>Set</strong>（无序、不可重复）：</p><ul><li><code>HashSet</code>​（基于哈希表）</li><li><code>LinkedHashSet</code>​（维护插入顺序）</li><li><code>TreeSet</code>​（基于红黑树，自然排序）</li></ul></li><li><p><strong>Queue</strong>（队列）：</p><ul><li><code>LinkedList</code>​（也可作为队列）</li><li><code>PriorityQueue</code>​（优先级队列）</li><li><code>ArrayDeque</code>​（双端队列）</li></ul></li></ul></li><li><p><strong>Map</strong>（存储键值对）：</p><ul><li><code>HashMap</code>​（非线程安全，允许 null 键&#x2F;值）</li><li><code>LinkedHashMap</code>​（维护插入顺序）</li><li><code>TreeMap</code>​（基于红黑树，键排序）</li><li><code>Hashtable</code>​（线程安全，不允许 null）</li><li><code>ConcurrentHashMap</code>​（线程安全的高并发 Map）</li></ul></li></ul><hr><h3 id="19-Collection-和-Collections-有什么区别？"><a href="#19-Collection-和-Collections-有什么区别？" class="headerlink" title="19. Collection 和 Collections 有什么区别？"></a><strong>19. Collection 和 Collections 有什么区别？</strong></h3><ul><li><strong>Collection</strong> 是集合接口，定义集合的基本操作（如 <code>add()</code>​, <code>remove()</code>​），是 <code>List</code>​、<code>Set</code>​、<code>Queue</code>​ 的父接口。</li><li><strong>Collections</strong> 是工具类，提供静态方法操作集合，如排序（<code>sort()</code>​）、同步包装（<code>synchronizedList()</code>​）等。<br><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.sort(list); <span class="comment">// 使用 Collections 的静态方法</span></span><br></pre></td></tr></table></figure><hr><h3 id="20-List、Set、Map-之间的区别是什么？"><a href="#20-List、Set、Map-之间的区别是什么？" class="headerlink" title="20. List、Set、Map 之间的区别是什么？"></a><strong>20. List、Set、Map 之间的区别是什么？</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>List</strong></th><th><strong>Set</strong></th><th><strong>Map</strong></th></tr></thead><tbody><tr><td><strong>有序性</strong></td><td>按插入顺序排序</td><td>无序（<code>HashSet</code>​）或按规则排序（<code>TreeSet</code>​）</td><td>键无序（<code>HashMap</code>​）或按规则排序（<code>TreeMap</code>​）</td></tr><tr><td><strong>重复元素</strong></td><td>允许</td><td>不允许</td><td>键唯一，值可重复</td></tr><tr><td><strong>实现类</strong></td><td>​<code>ArrayList</code>​, <code>LinkedList</code>​</td><td>​<code>HashSet</code>​, <code>TreeSet</code>​</td><td>​<code>HashMap</code>​, <code>TreeMap</code>​</td></tr><tr><td><strong>底层结构</strong></td><td>动态数组&#x2F;链表</td><td>哈希表&#x2F;红黑树</td><td>哈希表&#x2F;红黑树</td></tr><tr><td><strong>典型用途</strong></td><td>需要顺序访问或频繁按索引操作</td><td>去重</td><td>键值对存储</td></tr></tbody></table><p><strong>应用场景</strong>：</p><ul><li><code>List</code>​：用户历史记录（需顺序）。</li><li><code>Set</code>​：唯一性校验（如用户 ID）。</li><li><code>Map</code>​：缓存（键快速查找值）。</li></ul><hr><h3 id="21-HashMap-和-Hashtable-有什么区别？"><a href="#21-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="21. HashMap 和 Hashtable 有什么区别？"></a><strong>21. HashMap 和 Hashtable 有什么区别？</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>HashMap</strong></th><th><strong>Hashtable</strong></th></tr></thead><tbody><tr><td><strong>线程安全</strong></td><td>非线程安全</td><td>线程安全（方法用 <code>synchronized</code>​ 修饰）</td></tr><tr><td><strong>Null 支持</strong></td><td>允许一个 null 键&#x2F;多个 null 值</td><td>不允许 null 键或值</td></tr><tr><td><strong>性能</strong></td><td>高（无锁竞争）</td><td>低（同步开销）</td></tr><tr><td><strong>继承关系</strong></td><td>继承 <code>AbstractMap</code>​</td><td>继承 <code>Dictionary</code>​（已过时）</td></tr><tr><td><strong>扩容机制</strong></td><td>容量翻倍</td><td>旧容量×2 +1</td></tr><tr><td><strong>哈希算法</strong></td><td>位运算优化</td><td>直接取模</td></tr></tbody></table><p><strong>使用建议</strong>：</p><ul><li>单线程用 <code>HashMap</code>​，多线程用 <code>ConcurrentHashMap</code>​（而非 <code>Hashtable</code>​）。</li></ul><hr><h3 id="22-如何决定使用-HashMap-还是-TreeMap？"><a href="#22-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="22. 如何决定使用 HashMap 还是 TreeMap？"></a><strong>22. 如何决定使用 HashMap 还是 TreeMap？</strong></h3><ul><li><p><strong>HashMap</strong>：</p><ul><li>适用场景：快速查找（O(1) 时间复杂度）、无需排序。</li><li>示例：缓存用户会话信息（键为用户 ID）。</li></ul></li><li><p><strong>TreeMap</strong>：</p><ul><li>适用场景：需要按键自然顺序或自定义顺序遍历（如按字典序排序）。</li><li>示例：统计成绩并按分数排序。</li></ul></li></ul><p><strong>底层结构</strong>：</p><ul><li><code>HashMap</code>​：数组 + 链表&#x2F;红黑树（链表长度 &gt;8 时转为红黑树）。</li><li><code>TreeMap</code>​：红黑树（保证有序性）。</li></ul><hr><h3 id="23-说一下-HashMap-的实现原理？"><a href="#23-说一下-HashMap-的实现原理？" class="headerlink" title="23. 说一下 HashMap 的实现原理？"></a><strong>23. 说一下 HashMap 的实现原理？</strong></h3><ol><li><p><strong>数据结构</strong>：数组 + 链表&#x2F;红黑树。</p></li><li><p><strong>哈希计算</strong>：</p><ul><li>通过 <code>key.hashCode()</code>​ 计算哈希值。</li><li>使用 <code>(n-1) &amp; hash</code>​ 确定数组下标（n 是数组长度）。</li></ul></li><li><p><strong>冲突解决</strong>：</p><ul><li>链表法（同一桶内链表存储）。</li><li>链表长度 &gt;8 时转为红黑树（提高查询效率）。</li></ul></li><li><p><strong>扩容机制</strong>：</p><ul><li>默认容量 16，负载因子 0.75，扩容后容量翻倍。</li><li>重新计算所有元素的哈希位置（耗时操作）。</li></ul></li></ol><p><strong>PUT 流程</strong>：</p><ol><li>计算键的哈希值。</li><li>定位到数组下标。</li><li>若该位置为空，直接插入；否则处理冲突（链表或红黑树）。</li></ol><hr><h3 id="24-说一下-HashSet-的实现原理？"><a href="#24-说一下-HashSet-的实现原理？" class="headerlink" title="24. 说一下 HashSet 的实现原理？"></a><strong>24. 说一下 HashSet 的实现原理？</strong></h3><ul><li><p><strong>底层实现</strong>：基于 <code>HashMap</code>​，所有元素作为 <code>HashMap</code>​ 的键存储，值统一为 <code>PRESENT</code>​（静态空对象）。</p></li><li><p><strong>去重机制</strong>：</p><ul><li>元素的 <code>hashCode()</code>​ 和 <code>equals()</code>​ 方法决定是否重复。</li><li>若两个对象的 <code>hashCode()</code>​ 相同且 <code>equals()</code>​ 返回 true，视为重复。<br><strong>示例</strong>：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">set.add(<span class="string">&quot;A&quot;</span>); <span class="comment">// 内部调用 HashMap.put(&quot;A&quot;, PRESENT)</span></span><br></pre></td></tr></table></figure><hr><h3 id="25-ArrayList-和-LinkedList-的区别是什么？"><a href="#25-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="25. ArrayList 和 LinkedList 的区别是什么？"></a><strong>25. ArrayList 和 LinkedList 的区别是什么？</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>ArrayList</strong></th><th><strong>LinkedList</strong></th></tr></thead><tbody><tr><td><strong>底层结构</strong></td><td>动态数组</td><td>双向链表</td></tr><tr><td><strong>随机访问</strong></td><td>O(1)（通过索引）</td><td>O(n)（需遍历链表）</td></tr><tr><td><strong>插入&#x2F;删除</strong></td><td>O(n)（需移动元素）</td><td>O(1)（仅修改指针）</td></tr><tr><td><strong>内存占用</strong></td><td>较少（仅存储数据）</td><td>较高（存储前后节点指针）</td></tr><tr><td><strong>适用场景</strong></td><td>频繁查询、少增删</td><td>频繁增删、少查询</td></tr></tbody></table><p><strong>应用示例</strong>：</p><ul><li><code>ArrayList</code>​：分页查询结果列表。</li><li><code>LinkedList</code>​：实现队列或栈。</li></ul><hr><h3 id="26-如何实现数组和-List-之间的转换？"><a href="#26-如何实现数组和-List-之间的转换？" class="headerlink" title="26. 如何实现数组和 List 之间的转换？"></a><strong>26. 如何实现数组和 List 之间的转换？</strong></h3><ul><li><p><strong>数组 → List</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(array)); <span class="comment">// 可操作增删</span></span><br></pre></td></tr></table></figure><ul><li>注意：<code>Arrays.asList()</code>​ 返回的 <code>List</code>​ 是固定大小的，需包装为 <code>ArrayList</code>​。</li></ul></li><li><p><strong>List → 数组</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="27-ArrayList-和-Vector-的区别？"><a href="#27-ArrayList-和-Vector-的区别？" class="headerlink" title="27. ArrayList 和 Vector 的区别？"></a><strong>27. ArrayList 和 Vector 的区别？</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>ArrayList</strong></th><th><strong>Vector</strong></th></tr></thead><tbody><tr><td><strong>线程安全</strong></td><td>非线程安全</td><td>线程安全（方法用 <code>synchronized</code>​ 修饰）</td></tr><tr><td><strong>扩容机制</strong></td><td>容量 ×1.5</td><td>容量 ×2</td></tr><tr><td><strong>性能</strong></td><td>高</td><td>低（同步开销）</td></tr><tr><td><strong>迭代器</strong></td><td>快速失败（Fail-Fast）</td><td>快速失败</td></tr></tbody></table><p><strong>建议</strong>：多线程环境下使用 <code>CopyOnWriteArrayList</code>​ 替代 <code>Vector</code>​。</p><hr><h3 id="28-Array-和-ArrayList-有何区别？"><a href="#28-Array-和-ArrayList-有何区别？" class="headerlink" title="28. Array 和 ArrayList 有何区别？"></a><strong>28. Array 和 ArrayList 有何区别？</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>Array</strong></th><th><strong>ArrayList</strong></th></tr></thead><tbody><tr><td><strong>容量</strong></td><td>固定长度</td><td>动态扩容</td></tr><tr><td><strong>类型支持</strong></td><td>基本类型和对象</td><td>仅对象（自动装箱&#x2F;拆箱）</td></tr><tr><td><strong>功能方法</strong></td><td>无内置方法</td><td>提供 <code>add()</code>​, <code>remove()</code>​ 等方法</td></tr><tr><td><strong>性能</strong></td><td>高（内存连续）</td><td>略低（需动态调整）</td></tr></tbody></table><hr><h3 id="29-在-Queue-中-poll-和-remove-有什么区别？"><a href="#29-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="29. 在 Queue 中 poll() 和 remove() 有什么区别？"></a><strong>29. 在 Queue 中 poll() 和 remove() 有什么区别？</strong></h3><ul><li><strong>poll()</strong> ：队列为空时返回 <code>null</code>​。</li><li><strong>remove()</strong> ：队列为空时抛出 <code>NoSuchElementException</code>​。<br><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.poll();    <span class="comment">// 返回 null  </span></span><br><span class="line">queue.remove();  <span class="comment">// 抛出异常</span></span><br></pre></td></tr></table></figure><hr><h3 id="30-哪些集合类是线程安全的？"><a href="#30-哪些集合类是线程安全的？" class="headerlink" title="30. 哪些集合类是线程安全的？"></a><strong>30. 哪些集合类是线程安全的？</strong></h3><ul><li><p><strong>遗留类</strong>：<code>Vector</code>​、<code>Hashtable</code>​、<code>Stack</code>​（不推荐，性能差）。</p></li><li><p><strong>同步包装类</strong>：<code>Collections.synchronizedList()</code>​、<code>synchronizedMap()</code>​。</p></li><li><p><strong>并发集合</strong>：</p><ul><li><code>ConcurrentHashMap</code>​（分段锁）</li><li><code>CopyOnWriteArrayList</code>​（写时复制）</li><li><code>BlockingQueue</code>​（阻塞队列，如 <code>ArrayBlockingQueue</code>​）。</li></ul></li></ul><hr><h3 id="31-迭代器-Iterator-是什么？"><a href="#31-迭代器-Iterator-是什么？" class="headerlink" title="31. 迭代器 Iterator 是什么？"></a><strong>31. 迭代器 Iterator 是什么？</strong></h3><ul><li><strong>定义</strong>：提供遍历集合的统一接口，包含 <code>hasNext()</code>​、<code>next()</code>​、<code>remove()</code>​ 方法。</li><li><strong>特点</strong>：单向遍历、快速失败（遍历时修改集合会抛出异常）。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="32-Iterator-怎么使用？有什么特点？"><a href="#32-Iterator-怎么使用？有什么特点？" class="headerlink" title="32. Iterator 怎么使用？有什么特点？"></a><strong>32. Iterator 怎么使用？有什么特点？</strong></h3><ul><li><p><strong>使用步骤</strong>：</p><ol><li>通过集合的 <code>iterator()</code>​ 获取迭代器。</li><li>使用 <code>hasNext()</code>​ 检查是否还有元素。</li><li>使用 <code>next()</code>​ 获取下一个元素。</li><li>可选 <code>remove()</code>​ 删除当前元素。</li></ol></li><li><p><strong>特点</strong>：</p><ul><li><strong>单向性</strong>：只能向前遍历。</li><li><strong>快速失败</strong>：遍历时检测到集合被修改（非通过迭代器自身方法），立即抛出 <code>ConcurrentModificationException</code>​。</li></ul></li></ul><hr><h3 id="33-Iterator-和-ListIterator-有什么区别？"><a href="#33-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="33. Iterator 和 ListIterator 有什么区别？"></a><strong>33. Iterator 和 ListIterator 有什么区别？</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>Iterator</strong></th><th><strong>ListIterator</strong></th></tr></thead><tbody><tr><td><strong>遍历方向</strong></td><td>单向</td><td>双向（支持 <code>previous()</code>​）</td></tr><tr><td><strong>修改操作</strong></td><td>仅 <code>remove()</code>​</td><td>支持 <code>add()</code>​、<code>set()</code>​</td></tr><tr><td><strong>索引访问</strong></td><td>无</td><td>提供 <code>nextIndex()</code>​、<code>previousIndex()</code>​</td></tr><tr><td><strong>适用范围</strong></td><td>所有集合</td><td>仅 <code>List</code>​ 集合</td></tr></tbody></table><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListIterator&lt;String&gt; lit = list.listIterator();</span><br><span class="line">lit.previous(); <span class="comment">// 反向遍历</span></span><br></pre></td></tr></table></figure><hr><h3 id="34-怎么确保一个集合不能被修改？"><a href="#34-怎么确保一个集合不能被修改？" class="headerlink" title="34. 怎么确保一个集合不能被修改？"></a><strong>34. 怎么确保一个集合不能被修改？</strong></h3><ul><li><p><strong>方法 1</strong>：使用 <code>Collections.unmodifiableXXX()</code>​ 包装集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(list);</span><br><span class="line">unmodifiableList.add(<span class="string">&quot;x&quot;</span>); <span class="comment">// 抛出 UnsupportedOperationException</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方法 2</strong>：使用不可变集合类（如 Guava 的 <code>ImmutableList</code>​）。</p></li><li><p><strong>方法 3</strong>：返回集合的副本（深拷贝）而非原引用。</p></li></ul><p><strong>注意</strong>：通过反射仍可能修改集合内容，需结合权限控制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-容器&quot;&gt;&lt;a href=&quot;#java-容器&quot; class=&quot;headerlink&quot; title=&quot;java 容器&quot;&gt;&lt;/a&gt;java 容器&lt;/h1&gt;&lt;h3 id=&quot;18-Java-容器都有哪些？&quot;&gt;&lt;a href=&quot;#18-Java-容器都有哪些？&quot; c</summary>
      
    
    
    
    <category term="Java面试题" scheme="http://example.com/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java面试题" scheme="http://example.com/tags/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://example.com/2025/02/17/java%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2025/02/17/java%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2025-02-17T04:00:00.000Z</published>
    <updated>2025-03-16T03:19:03.859Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a><strong>网络</strong></h3><h4 id="79-HTTP-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#79-HTTP-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="79. HTTP 响应码 301 和 302 代表的是什么？有什么区别？"></a><strong>79. HTTP 响应码 301 和 302 代表的是什么？有什么区别？</strong></h4><ul><li><p><strong>301（Moved Permanently）</strong> ：永久重定向，客户端后续请求应直接使用新URL，搜索引擎会更新索引。</p></li><li><p><strong>302（Found）</strong> ：临时重定向，客户端后续请求仍使用原URL，搜索引擎保留原URL。</p></li><li><p><strong>区别</strong>：</p><ul><li><strong>缓存行为</strong>：浏览器会缓存301响应，后续直接跳转新URL；302每次需先访问原URL再跳转。</li><li><strong>SEO影响</strong>：301会将原URL权重转移到新URL，302不会。</li></ul></li></ul><hr><h4 id="80-forward-和-redirect-的区别？"><a href="#80-forward-和-redirect-的区别？" class="headerlink" title="80. forward 和 redirect 的区别？"></a><strong>80. forward 和 redirect 的区别？</strong></h4><ul><li><p><strong>forward（转发）</strong> ：</p><ul><li><strong>服务器内部跳转</strong>，客户端无感知，URL不变。</li><li>一次请求，数据通过<code>request</code>​共享。</li></ul></li><li><p><strong>redirect（重定向）</strong> ：</p><ul><li><strong>客户端重新发起请求</strong>，URL变为目标地址。</li><li>两次请求，数据无法直接共享（需通过<code>session</code>​或参数传递）。</li></ul></li><li><p><strong>本质</strong>：forward是服务器行为，redirect是客户端行为。</p></li></ul><hr><h4 id="81-简述-TCP-和-UDP-的区别？"><a href="#81-简述-TCP-和-UDP-的区别？" class="headerlink" title="81. 简述 TCP 和 UDP 的区别？"></a><strong>81. 简述 TCP 和 UDP 的区别？</strong></h4><table><thead><tr><th><strong>维度</strong></th><th>TCP（传输控制协议）</th><th>UDP（用户数据报协议）</th></tr></thead><tbody><tr><td><strong>连接性</strong></td><td>面向连接（三次握手）</td><td>无连接</td></tr><tr><td><strong>可靠性</strong></td><td>可靠传输（确认、重传机制）</td><td>不可靠（尽最大努力交付）</td></tr><tr><td><strong>数据顺序</strong></td><td>保证数据顺序</td><td>不保证顺序</td></tr><tr><td><strong>头部开销</strong></td><td>大（20字节）</td><td>小（8字节）</td></tr><tr><td><strong>适用场景</strong></td><td>文件传输、Web浏览</td><td>实时视频、语音通话</td></tr></tbody></table><hr><h4 id="82-TCP-为什么要三次握手，两次不行吗？为什么？"><a href="#82-TCP-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="82. TCP 为什么要三次握手，两次不行吗？为什么？"></a><strong>82. TCP 为什么要三次握手，两次不行吗？为什么？</strong></h4><ul><li><p><strong>三次握手目的</strong>：确保双方收发能力正常，防止历史连接干扰。</p></li><li><p><strong>两次握手问题</strong>：</p><ul><li><strong>失效连接请求</strong>：若客户端第一次握手报文延迟，服务器直接建立连接，但客户端已放弃，导致服务器资源浪费。</li><li><strong>无法确认客户端接收能力</strong>：服务器需确认客户端能收到自己的响应。</li></ul></li><li><p><strong>过程</strong>：客户端→服务器（SYN），服务器→客户端（SYN+ACK），客户端→服务器（ACK）。</p></li></ul><hr><h4 id="83-TCP-粘包是怎么产生的？"><a href="#83-TCP-粘包是怎么产生的？" class="headerlink" title="83. TCP 粘包是怎么产生的？"></a><strong>83. TCP 粘包是怎么产生的？</strong></h4><ul><li><p><strong>原因</strong>：</p><ol><li><strong>发送方粘包</strong>：Nagle算法合并小数据包。</li><li><strong>接收方粘包</strong>：接收缓冲区数据堆积，未及时读取。</li></ol></li><li><p><strong>解决方案</strong>：</p><ul><li><strong>消息定长</strong>：固定每个消息长度。</li><li><strong>分隔符</strong>：如<code>\n</code>​标识消息边界。</li><li><strong>头部声明长度</strong>：在数据包头部添加长度字段。</li></ul></li></ul><hr><h4 id="84-OSI-的七层模型有哪些？"><a href="#84-OSI-的七层模型有哪些？" class="headerlink" title="84. OSI 的七层模型有哪些？"></a><strong>84. OSI 的七层模型有哪些？</strong></h4><table><thead><tr><th><strong>层级</strong></th><th><strong>功能</strong></th><th><strong>典型协议&#x2F;设备</strong></th></tr></thead><tbody><tr><td>应用层</td><td>用户接口（HTTP、FTP）</td><td>HTTP、DNS、SMTP</td></tr><tr><td>表示层</td><td>数据格式转换、加密&#x2F;解密</td><td>SSL、JPEG</td></tr><tr><td>会话层</td><td>建立&#x2F;管理会话</td><td>NetBIOS</td></tr><tr><td>传输层</td><td>端到端连接（TCP、UDP）</td><td>TCP、UDP</td></tr><tr><td>网络层</td><td>路由寻址（IP）</td><td>IP、路由器</td></tr><tr><td>数据链路层</td><td>帧传输、MAC地址访问</td><td>以太网、交换机</td></tr><tr><td>物理层</td><td>物理介质传输（比特流）</td><td>光纤、集线器</td></tr></tbody></table><hr><h4 id="85-GET-和-POST-请求有哪些区别？"><a href="#85-GET-和-POST-请求有哪些区别？" class="headerlink" title="85. GET 和 POST 请求有哪些区别？"></a><strong>85. GET 和 POST 请求有哪些区别？</strong></h4><table><thead><tr><th><strong>维度</strong></th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td><strong>参数位置</strong></td><td>URL末尾（查询字符串）</td><td>请求体（Body）</td></tr><tr><td><strong>数据长度</strong></td><td>受URL长度限制（约2KB）</td><td>无限制（服务器配置限制）</td></tr><tr><td><strong>安全性</strong></td><td>参数可见（历史记录中暴露）</td><td>参数不可见（但仍需加密）</td></tr><tr><td><strong>幂等性</strong></td><td>幂等（多次请求结果相同）</td><td>非幂等</td></tr><tr><td><strong>缓存</strong></td><td>可被缓存</td><td>默认不缓存</td></tr></tbody></table><hr><h4 id="86-如何实现跨域？"><a href="#86-如何实现跨域？" class="headerlink" title="86. 如何实现跨域？"></a><strong>86. 如何实现跨域？</strong></h4><ul><li><p><strong>跨域条件</strong>：协议、域名、端口任一不同即触发同源策略限制。</p></li><li><p><strong>解决方案</strong>：</p><ol><li><strong>CORS（跨域资源共享）</strong> ：服务器设置响应头（如<code>Access-Control-Allow-Origin: *</code>​）。</li><li><strong>JSONP</strong>：利用<code>&lt;script&gt;</code>​标签跨域加载数据（仅支持GET）。</li><li><strong>代理服务器</strong>：同域服务端转发请求（如Nginx反向代理）。</li><li><strong>WebSocket</strong>：全双工通信协议，不受同源策略限制。</li></ol></li></ul><hr><h4 id="87-JSONP-实现原理？"><a href="#87-JSONP-实现原理？" class="headerlink" title="87. JSONP 实现原理？"></a><strong>87. JSONP 实现原理？</strong></h4><ul><li><p><strong>原理</strong>：利用<code>&lt;script&gt;</code>​标签不受同源策略限制的特性。</p></li><li><p><strong>步骤</strong>：</p><ol><li>客户端定义回调函数（如<code>handleResponse</code>​）。</li><li>动态创建<code>&lt;script&gt;</code>​标签，URL中指定回调函数名（如<code>?callback=handleResponse</code>​）。</li><li>服务器返回数据包裹在回调函数中（如<code>handleResponse(&#123;&quot;data&quot;: &quot;value&quot;&#125;)</code>​）。</li><li>客户端执行回调函数处理数据。</li></ol></li><li><p><strong>限制</strong>：仅支持GET请求，安全性较低。</p></li></ul><hr><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h3><h4 id="88-常见的设计模式有哪些？"><a href="#88-常见的设计模式有哪些？" class="headerlink" title="88. 常见的设计模式有哪些？"></a><strong>88. 常见的设计模式有哪些？</strong></h4><ol><li><p><strong>创建型</strong>：</p><ul><li><strong>单例模式</strong>：确保类仅有一个实例（如数据库连接池）。</li><li><strong>工厂模式</strong>：解耦对象创建（简单工厂、抽象工厂）。</li></ul></li><li><p><strong>结构型</strong>：</p><ul><li><strong>适配器模式</strong>：兼容不同接口（如充电器转换头）。</li><li><strong>代理模式</strong>：控制对象访问（如动态代理）。</li></ul></li><li><p><strong>行为型</strong>：</p><ul><li><strong>观察者模式</strong>：一对多依赖通知（如事件监听）。</li><li><strong>策略模式</strong>：动态切换算法（如支付方式选择）。</li></ul></li></ol><hr><h4 id="89-简单工厂和抽象工厂有什么区别？"><a href="#89-简单工厂和抽象工厂有什么区别？" class="headerlink" title="89. 简单工厂和抽象工厂有什么区别？"></a><strong>89. 简单工厂和抽象工厂有什么区别？</strong></h4><table><thead><tr><th><strong>维度</strong></th><th>简单工厂</th><th>抽象工厂</th></tr></thead><tbody><tr><td><strong>产品等级</strong></td><td>单一产品族（同一接口的不同实现）</td><td>多个产品族（多个相关产品组合）</td></tr><tr><td><strong>扩展性</strong></td><td>新增产品需修改工厂类（违反开闭原则）</td><td>新增产品族容易，新增产品种类难</td></tr><tr><td><strong>复杂度</strong></td><td>简单（一个工厂类）</td><td>复杂（多个工厂类，接口抽象）</td></tr><tr><td><strong>适用场景</strong></td><td>产品类型固定，变化少</td><td>需要灵活组合多个关联产品</td></tr></tbody></table><ul><li><p><strong>示例</strong>：</p><ul><li><strong>简单工厂</strong>：生产不同品牌的汽车（所有汽车实现同一接口）。</li><li><strong>抽象工厂</strong>：生产汽车及其配套的轮胎、座椅（多个关联产品组合）。</li></ul></li></ul><hr><p>以上回答聚焦核心概念和关键区别，避免冗余代码示例，适合快速理解和面试回顾。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;&lt;strong&gt;网络&lt;/strong&gt;&lt;/h3&gt;&lt;h4 id=&quot;79-HTTP-响应码-301-和-302-代表的是什么？有什么区别？&quot;&gt;&lt;a href=&quot;#7</summary>
      
    
    
    
    <category term="Java面试题" scheme="http://example.com/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="Java面试题" scheme="http://example.com/tags/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2025/02/16/hello-world/"/>
    <id>http://example.com/2025/02/16/hello-world/</id>
    <published>2025-02-16T14:08:32.872Z</published>
    <updated>2025-02-16T14:08:32.872Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
